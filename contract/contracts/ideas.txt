TODO: Must be deleted later !!!


###################################################################################################

4 types of IDs:
- Accreditation ID
- Certificate ID
- Issuer address
- Applicant address

8 types of data types:
- Accreditation
- Accreditation[]
- Certificate
- Certificate[]
- Issuer
- Issuer[]
- Applicant
- Applicant[]

###################################################################################################

Blockchain does not have proper relational database implementation
Need to brainstorm data structures such as maps and foreign key relations that allows accessing data using ID
Some mappings will make no sense, mark as n/a

Data structure brainstorming via brute force:

Accreditation ID    =>    Accreditation: 	    AccreditationStorage, mapping
Accreditation ID    =>    Accreditation[]: 	    n/a
Accreditation ID    =>    Certificate: 		    n/a
Accreditation ID    =>    Certificate[]: 	    CertificateStorage, mapping
Accreditation ID    =>    Issuer: 		        ID => Acc => Issuer address => Issuer, mapping in IssuerStorage
Accreditation ID    =>    Issuer[]: 		    n/a
Accreditation ID    =>    Applicant: 		    n/a
Accreditation ID    =>    Applicant[]: 		    ID => Acc => Cert[] => Applicant address[] => Applicant[]
Certificate ID      =>    Accreditation: 	    ID => Cert => Acc ID => Acc
Certificate ID      =>    Accreditation[]: 	    n/a
Certificate ID      =>    Certificate: 		    CertificateStorage, mapping
Certificate ID      =>    Certificate[]: 	    n/a
Certificate ID      =>    Issuer: 		        ID => Cert => Issuer address => Issuer, mapping in CertificateStorage and IssuerStorage
Certificate ID      =>    Issuer[]: 		    n/a
Certificate ID      =>    Applicant: 		    ID => Cert => Applicant address => Applicant
Certificate ID      =>    Applicant[]: 		    n/a
Issuer address      =>    Accreditation: 	    n/a
Issuer address      =>    Accreditation[]: 	    Issuer address => Accreditation[], mapping in AccreditationStorage
Issuer address      =>    Certificate: 		    n/a
Issuer address      =>    Certificate[]: 	    Issuer address => Certificate[], mapping in CertificateStorage
Issuer address      =>    Issuer: 		        IssuerStorage, mapping
Issuer address      =>    Issuer[]: 		    n/a
Issuer address      =>    Applicant: 		    n/a
Issuer address      =>    Applicant[]: 		    Issuer address => Acc[] => Applicant[] (flatten and create set), not sure if worth it
Applicant address   =>    Accreditation: 	    n/a
Applicant address   =>    Accreditation[]: 	    Applicant address => Cert[] => Acc[]
Applicant address   =>    Certificate: 		    n/a
Applicant address   =>    Certificate[]: 	    Applicant address => Cert[], CertificateStorage, mapping
Applicant address   =>    Issuer: 		        n/a
Applicant address   =>    Issuer[]: 		    Applicant address => Cert[] => Issuer address[] => Issuer[]
Applicant address   =>    Applicant: 		    ApplicantStorage, mapping
Applicant address   =>    Applicant[]: 		    n/a

###################################################################################################

After filtering away n/a:
(Mark user entry points with *)

 Accreditation ID    =>    Accreditation: 	    AccreditationStorage, mapping
 Accreditation ID    =>    Certificate[]: 	    CertificateStorage, mapping
 Accreditation ID    =>    Issuer: 		        ID => Acc => Issuer address => Issuer, mapping in IssuerStorage
 Accreditation ID    =>    Applicant[]: 		ID => Acc => Cert[] => Applicant address[] => Applicant[]
 Certificate ID      =>    Accreditation: 	    ID => Cert => Acc ID => Acc
 Certificate ID      =>    Certificate: 		CertificateStorage, mapping
 Certificate ID      =>    Issuer: 		        ID => Cert => Issuer address => Issuer, mapping in CertificateStorage and IssuerStorage
 Certificate ID      =>    Applicant: 		    ID => Cert => Applicant address => Applicant
*Issuer address      =>    Accreditation[]: 	Issuer address => Accreditation[], mapping in AccreditationStorage
?Issuer address      =>    Certificate[]: 	    Issuer address => Certificate[], mapping in CertificateStorage
*Issuer address      =>    Issuer: 		        IssuerStorage, mapping
 Issuer address      =>    Applicant[]: 		Issuer address => Acc[] => Applicant[] (flatten and create set), not sure if worth it, another use case is applicant register to issuer, add modifer
 Applicant address   =>    Accreditation[]: 	Applicant address => Cert[] => Acc[]
*Applicant address   =>    Certificate[]: 	    Applicant address => Cert[], CertificateStorage, mapping
 Applicant address   =>    Issuer[]: 		    Applicant address => Cert[] => Issuer address[] => Issuer[]
*Applicant address   =>    Applicant: 		    ApplicantStorage, mapping

###################################################################################################

Organize all needed mappings and array maps:

Mappings:
- Accreditation ID => Accreditation
- Accreditation ID => Certificate[]
- Issuer address => Issuer
- Applicant address => Applicant
- Certificate ID => Certificate
- Issuer address => Accreditation[]
- Issuer address => Certificate[] (may not worth)
- Issuer address => Applicant[] (could be applicant registration to take exam and accept certs from issuer) (may not necessarily have Cert or Accred in between)
- Applicant address => Certificate[]

Array maps:
- Certificate to Applicant address
- Certificate to Issuer address

Others:
- Certificate[] => Accreditation ID[] => Accreditation[] (need flatten IDs)
- Accreditation[] => [Cert[]] => Cert[] (need flatten, may not worth)
- Issuer address => Certificate[] => Applicant[] (need make set, may not worth)
- Issuer address => Accreditation[] => Applicant[] (need flatten and make set, may not worth)

###################################################################################################

Reorganize
In order to save memory, right hand side data in mapping will be kept in corresponding contract:
e.g. Issuer address => Accreditation[] case --------> store in AccreditationStorage
In order to save memory, left hand side data in array parallel map function will be kept in corresponding contract:
e.g. Certificate to Issuer address case --------> implement function in CertificateStorage

IssuerStorage:
- Issuer address => Issuer

ApplicantStorage:
- Applicant address => Applicant
- Issuer address => Applicant[] (could be applicant registration to take exam and accept certs from issuer) (may not necessarily have Cert or Accred in between)

AccreditationStorage:
- Accreditation ID => Accreditation
- Issuer address => Accreditation[]

CertificateStorage:
- Accreditation ID => Certificate[]
- Certificate ID => Certificate
- Issuer address => Certificate[] (may not worth)
- Applicant address => Certificate[]
- Certificate to Issuer address (array)
- Certificate to Applicant address (array)

###################################################################################################

(Optional) Identify possible infinite loop when hack, ReentrancyGuard to prevent Reentrancy attacks

###################################################################################################
